import json
import os
from dataclasses import dataclass
from pprint import pprint
from subprocess import PIPE, Popen
from typing import List
from unittest import TestCase


DEFAULT_COMMAND_TIMEOUT = 20


@dataclass
class PyShellCommand(object):
    name: str
    command: List[str]
    extra: dict

    @classmethod
    def from_d(cls, name: str, command: List[str], **d):
        return PyShellCommand(name, command, extra=d)

    def gen_test(self):
        def the_test(self_for_test):
            process = Popen(self.command, stdout=PIPE, stderr=PIPE)
            process.wait(timeout=self.timeout)

            if self.print_output:
                out = process.stdout.read().decode("utf-8")
                print(out)
            assert process.returncode == 0, process.stderr.read()
        return the_test

    def get(self, name: str, default=None):
        return self.extra.get(name, default)

    @property
    def timeout(self):
        return self.get("timeout", default=DEFAULT_COMMAND_TIMEOUT)

    @property
    def print_output(self):
        return self.get("print_output", False)

    @property
    def test_name(self):
        return f"test_{self.name}"


@dataclass
class PyShellTestGenerator(object):
    commands: List[PyShellCommand]

    @classmethod
    def from_json(cls, path: str) -> "PyShellTestGenerator":
        if not os.path.exists(path):
            raise FileNotFoundError(path)
        with open(path) as f:
            settings = json.load(f)

        comms = []
        for name, d in settings.items():
            com = PyShellCommand.from_d(name, **d)
            comms.append(com)

        return PyShellTestGenerator(comms)

    def generate(self):
        cls = type('A', (TestCase,),
                   {'__doc__': f'class generated by {self.__class__.__name__}'}
                   )
        for com in self.commands:
            t = com.gen_test()
            setattr(cls, com.test_name, t)
        return cls

